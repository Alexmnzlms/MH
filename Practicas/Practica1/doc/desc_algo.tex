\newpage
\section{Descripción de los algoritmos empleados}
%MAX 4 PAGS
%Breve descripción de la aplicación de los algoritmos empleados al problema (máximo 4 páginas): Todas las consideraciones comunes a los distintos algoritmos se describirán en este apartado, que será previo a la descripción de los algoritmos específicos. Incluirá por ejemplo la descripción del esquema de representación de soluciones y la descripción en pseudocódigo (no código) de la función objetivo y los operadores comunes.

En esta práctica se han implementado dos algoritmos:
\begin{itemize}
   \item \textbf{K-medias Restringido Débil}: Algoritmo de heurística greedy, que busca minimizar tanto la desviación general como la \emph{infeasibility}. $ F_{objetivo} = \bar{C} + infeasibility $
   \item \textbf{Búsqueda Local}: Como método de búsqueda por trayectorias utilizaremos la búsqueda local, en este caso, se busca minimizar la desviación general y la \emph{infeasibility} multiplicado por un parametro $ \lambda $ que se describira mas adelante. $ F_{objetivo} = \bar{C} + (infeasibility \cdot \lambda) $
\end{itemize}

\subsection{Representación de los datos}
Los datos comunes a ambos algoritmos se repesentan de la siguiente manera:

\begin{itemize}
   \item Para los \textbf{datos} utilizo una matriz \emph{posiciones} de numeros reales de dimensión $ i \times n $.
   \begin{minted}
   [fontsize=\footnotesize, linenos]
   {cpp}
      double: matriz[i][n] posiciones
   \end{minted}

   \item Para los \textbf{centroides} de cada cluster utilizo una matriz \emph{centroides} de dimensión $ k \times n $.
   \begin{minted}
   [fontsize=\footnotesize, linenos]
   {cpp}
      double: matriz[k][n] centroides
   \end{minted}

   \item Para las \textbf{restricciones}, he elegido no utlizar las representación en forma de matriz, porque es muy costoso recorrerla secuencialmente, y la representación en forma de lista no te permite acceder a un elemento en concreto, por eso he decidido utilizar un map \emph{restricciones}. Este tipo de estructura se puede recorrer secuencialmete de forma eficiente y ademas, existe un operador de búsqueda para poder acceder a un elemento concreto. El map se compone de dos elementos: la clave y el valor. La clave es la pareja de elementos $ x_{i}, x_{j}$ y el valor es 1 si la resticcion es de tipo \textbf{ML} o -1 si es de tipo \textbf{CL}.
   \begin{minted}
   [fontsize=\footnotesize, linenos]
   {cpp}
      Pareja(int,int),int: map restricciones
   \end{minted}

   \item Los elementos $ x_{i} $ que pertenecen a los distintos \textbf{clusters} los almaceno en una matriz \emph{clusters} de dimensión $ k \times i $.
   \begin{minted}
   [fontsize=\footnotesize, linenos]
   {cpp}
      double: matriz[k][i] clusters
   \end{minted}

   \item Finalmente la \textbf{particion} \emph{C} la represnto en un vector de enteros \emph{solucion}, en los que posicion del vector \emph{i} indica el elemento $ x_{i} $ y el contenido de la posicion \emph{i}, \emph{solucion[i]} indica el cluster $ c_{i} $ al que pertenece.
   \begin{minted}
   [fontsize=\footnotesize, linenos]
   {cpp}
      int: vector[i] solucion
   \end{minted}
\end{itemize}


\subsection{Operadores comunes}
Hay una serie de operadores que son comunes a los dos algoritmos, los describo a continuación:
\begin{itemize}
   \item Operador \textbf{calcular\_centroide(cluster i)}:
   \begin{minted}
   [fontsize=\footnotesize, linenos]
   {cpp}
   Para cada caracteristica u del centroide i:
      u = 0

   Para cada elemento j del cluster i:
      Para cada caracteristica c, u del elemento j, centroide i:
         u += 1/k * c
   \end{minted}
   \item Operador \textbf{distancia\_intracluster(cluster i)}:
   \begin{minted}
   [fontsize=\footnotesize, linenos]
   {cpp}
   Para todos los clusters:
      d_intracluster = 0

   Para cada elemento j del cluster i:
      Para cada caracteristica c, u del elemento j, centroide i :
         d_intracluster += 1/k * abs(c - u) * abs(c - u)
   \end{minted}
   \item Operador \textbf{desviación\_general()}:
   \begin{minted}
   [fontsize=\footnotesize, linenos]
   {cpp}
   desv_gen = 0

   Para cada distancia_intracluster i del cluster i:
      desv_gen += 1/k * i
   \end{minted}

   \item Operador \textbf{limpiar\_clusters()}:
   \begin{minted}
   [fontsize=\footnotesize, linenos]
   {cpp}
   Para cada cluster i:
      Eliminar elementos de i

   infactibilidad = 0
   \end{minted}
   \item Operador \textbf{restricciones\_incumplidas(elemento n, cluster c)}:
   \begin{minted}
   [fontsize=\footnotesize, linenos]
   {cpp}
   incumplidas = 0

   Para cada elemento i del cluster c:
      Buscar en restricciones la pareja (n,elemento i)
      Si existe Y valor es -1:
         incumplidas++

   Para los cluster del conjunto distintos de c:
      Para cada elemento i del cluster j:
         Buscar en restricciones la pareja (n,elemento i)
         Si existe Y valor es 1:
            incumplidas++

   Devolver incumplidas

   \end{minted}
\end{itemize}
